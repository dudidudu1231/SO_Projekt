#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <semaphore.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/msg.h>
#include <signal.h>

#define FIFO_NAME "/home/kuba/Desktop/projekt/my_fifo"
#define ByteSize 256
#define SHM_NAME "/shared_memory"

struct msg {
    long mtype;
    char mtext[ByteSize];
};

sem_t *sem_1, *sem_2, *sem_3;
char buffer[ByteSize];
int msgid_global;
pid_t p1_pid, p2_pid, p3_pid;
volatile sig_atomic_t program_running = 1;

void report_and_exit(const char *msg) {
    perror(msg);
    exit(1);
}

void process_signal_handler(int signo) {
    // Pusty handler
}

void interrupt_handler(int signo) {
    printf("\nOtrzymano sygnał %d. Czyszczenie i wyjście...\n", signo);
    program_running = 0;
    
    sem_unlink("/sem_1");
    sem_unlink("/sem_2");
    sem_unlink("/sem_3");
    shm_unlink(SHM_NAME);
    msgctl(msgid_global, IPC_RMID, NULL);
    unlink(FIFO_NAME);
    
    if (p1_pid > 0) kill(p1_pid, SIGTERM);
    if (p2_pid > 0) kill(p2_pid, SIGTERM);
    if (p3_pid > 0) kill(p3_pid, SIGTERM);
    
    exit(1);
}

int zlicz_znaki(const char *str) {
    int count = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] != '\n' && str[i] != '\r') count++;
    }
    return count;
}

void P1(int fifo_fd, int msgid) {
    struct msg message;
    while (program_running) {
        printf("\nMenu:\n");
        printf("1. Czytaj z klawiatury (stdin)\n");
        printf("2. Czytaj z pliku (każdy wiersz kończy się <EOL>)\n");
        printf("Wybierz opcję: ");

        int choice;
        scanf("%d", &choice);
        getchar();

        if (choice == 1) {
            while (program_running) {
                printf("P1(%d): Wprowadź tekst do FIFO (lub 'exit' aby zakończyć): ", getpid());
                if (fgets(buffer, ByteSize, stdin) == NULL) break;
                
                if (strncmp(buffer, "exit", 4) == 0) {
                    program_running = 0;
                    write(fifo_fd, "exit", 5);
                    break;
                }
                
                // Zapisz dane do FIFO
                write(fifo_fd, buffer, strlen(buffer) + 1);
                printf("P1(%d): Linia wysłana do FIFO\n", getpid());
                
                // Powiadom P2
                kill(p2_pid, SIGUSR1);
                
                // Czekaj na potwierdzenie
                if (msgrcv(msgid, &message, sizeof(message.mtext), 1, 0) != -1) {
                    printf("P1(%d): Otrzymano potwierdzenie: %s\n", getpid(), message.mtext);
                }
            }
        } else if (choice == 2) {
            char filename[256];
            printf("Podaj nazwę pliku: ");
            fgets(filename, sizeof(filename), stdin);
            filename[strcspn(filename, "\n")] = 0;

            FILE *file = fopen(filename, "r");
            if (!file) {
                perror("Nie udało się otworzyć pliku");
                continue;
            }

            while (fgets(buffer, ByteSize, file) && program_running) {
                // Zapisz linię do FIFO
                write(fifo_fd, buffer, strlen(buffer) + 1);
                printf("P1(%d): Wysłano linię: %s", getpid(), buffer);
                
                // Powiadom P2
                kill(p2_pid, SIGUSR1);
                
                // Czekaj na potwierdzenie
                if (msgrcv(msgid, &message, sizeof(message.mtext), 1, 0) != -1) {
                    printf("P1(%d): Otrzymano potwierdzenie: %s\n", getpid(), message.mtext);
                }
                
                usleep(100000); // Krótkie opóźnienie dla stabilności
            }
            
            fclose(file);
        }
    }
    
    close(fifo_fd);
}

void P2(char *shared_memory, int msgid) {
    struct sigaction sa;
    sa.sa_handler = process_signal_handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGUSR1, &sa, NULL);
    
    int fifo_fd = open(FIFO_NAME, O_RDONLY | O_NONBLOCK);  // Dodano O_NONBLOCK
    if (fifo_fd == -1) report_and_exit("open FIFO error");

    fd_set read_fds;
    struct timeval tv;
    
    while (program_running) {
        FD_ZERO(&read_fds);
        FD_SET(fifo_fd, &read_fds);
        
        tv.tv_sec = 1;
        tv.tv_usec = 0;
        
        int ready = select(fifo_fd + 1, &read_fds, NULL, NULL, &tv);
        
        if (ready > 0 && FD_ISSET(fifo_fd, &read_fds)) {
            memset(buffer, 0, ByteSize);
            ssize_t bytes_read = read(fifo_fd, buffer, ByteSize);
            
            if (bytes_read > 0) {
                if (strncmp(buffer, "exit", 4) == 0) {
                    strcpy(shared_memory, "exit");
                    sem_post(sem_3);
                    break;
                }

                printf("P2(%d): Odczytano z FIFO: %s", getpid(), buffer);

                int char_count = zlicz_znaki(buffer);
                sprintf(shared_memory, "%d", char_count);
                printf("P2(%d): Liczba znaków: %d\n", getpid(), char_count);

                // Notyfikacja P3
                sem_post(sem_3);
                kill(p3_pid, SIGUSR2);
                
                // Czekaj na P3
                sem_wait(sem_2);

                // Wyślij potwierdzenie do P1
                struct msg message;
                message.mtype = 1;
                snprintf(message.mtext, sizeof(message.mtext), "Przetworzono dane");
                msgsnd(msgid, &message, sizeof(message.mtext), 0);
            }
        }
    }

    close(fifo_fd);
}

// Proces P3 pozostaje bez zmian
void P3(char *shared_memory, int msgid) {
    struct sigaction sa;
    sa.sa_handler = process_signal_handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    sigaction(SIGUSR2, &sa, NULL);
    
    while (program_running) {
        sem_wait(sem_3);

        if (strncmp(shared_memory, "exit", 4) == 0) {
            break;
        }

        printf("P3(%d): Otrzymano liczbę znaków: %s\n", getpid(), shared_memory);
        printf("----------------------------------------\n");

        sem_post(sem_2);
    }
}

// main pozostaje bez zmian
int main() {
    sem_unlink("/sem_1");
    sem_unlink("/sem_2");
    sem_unlink("/sem_3");
    unlink(FIFO_NAME);
    
    signal(SIGTERM, interrupt_handler);
    signal(SIGINT, interrupt_handler);
    
    if (mkfifo(FIFO_NAME, 0666) == -1) {
        if (errno != EEXIST) report_and_exit("mkfifo error");
    }

    sem_1 = sem_open("/sem_1", O_CREAT | O_EXCL, 0666, 0);
    sem_2 = sem_open("/sem_2", O_CREAT | O_EXCL, 0666, 0);
    sem_3 = sem_open("/sem_3", O_CREAT | O_EXCL, 0666, 0);

    if (sem_1 == SEM_FAILED || sem_2 == SEM_FAILED || sem_3 == SEM_FAILED) {
        report_and_exit("sem_open error");
    }

    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) report_and_exit("shm_open error");
    
    if (ftruncate(shm_fd, ByteSize) == -1) report_and_exit("ftruncate error");

    char *shared_memory = mmap(NULL, ByteSize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_memory == MAP_FAILED) report_and_exit("mmap error");

    msgid_global = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if (msgid_global == -1) report_and_exit("msgget error");

    p2_pid = fork();
    if (p2_pid == 0) {
        P2(shared_memory, msgid_global);
        exit(0);
    }

    p3_pid = fork();
    if (p3_pid == 0) {
        P3(shared_memory, msgid_global);
        exit(0);
    }

    p1_pid = fork();
    if (p1_pid == 0) {
        int fifo_fd = open(FIFO_NAME, O_WRONLY);
        if (fifo_fd == -1) report_and_exit("open FIFO error");
        P1(fifo_fd, msgid_global);
        exit(0);
    }

    wait(NULL);
    wait(NULL);
    wait(NULL);

    sem_close(sem_1);
    sem_close(sem_2);
    sem_close(sem_3);
    sem_unlink("/sem_1");
    sem_unlink("/sem_2");
    sem_unlink("/sem_3");
    shm_unlink(SHM_NAME);
    msgctl(msgid_global, IPC_RMID, NULL);
    unlink(FIFO_NAME);
    munmap(shared_memory, ByteSize);
    close(shm_fd);

    return 0;
}
