#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <unistd.h>

// Struktura dla kolejki komunikatów
typedef struct {
    long msg_type;
    int signal;
} msgsig;

int msgid_p1, msgid_p2, msgid_p3; // Osobne kolejki dla P1, P2, P3

// PID-y procesów
pid_t pid1, pid2, pid3;

// Handler rodzica
void parent_signal_handler(int sig) {
    printf("[PARENT] Otrzymałem sygnał %d\n", sig);
    
    // Tworzymy komunikat
    msgsig msg;
    msg.msg_type = 1;
    msg.signal = sig;
    
    // Wysyłamy do kolejki P1
    if (msgsnd(msgid_p1, &msg, sizeof(int), 0) == -1) {
        perror("[PARENT] msgsnd error do P1");
    }
    printf("[PARENT] Przekazuję SIGUSR1 do P1\n");
    kill(pid1, SIGUSR1);
}

// Handler P1
void p1_signal_handler(int sig) {
    printf("[P1] Odebrałem SIGUSR1 od rodzica\n");
    
    // Odczyt sygnału z kolejki
    msgsig msg;
    if (msgrcv(msgid_p1, &msg, sizeof(int), 1, 0) == -1) {
        perror("[P1] msgrcv error");
        return;
    }
    
    printf("[P1] Przekazuję SIGUSR1 do P2\n");
    
    // Wysyłamy do kolejki P2
    if (msgsnd(msgid_p2, &msg, sizeof(int), 0) == -1) {
        perror("[P1] msgsnd error do P2");
    }
    kill(pid2, SIGUSR1);
}

// Handler P2
void p2_signal_handler(int sig) {
    printf("[P2] Odebrałem SIGUSR1 od P1\n");
    
    // Odczyt sygnału z kolejki
    msgsig msg;
    if (msgrcv(msgid_p2, &msg, sizeof(int), 1, 0) == -1) {
        perror("[P2] msgrcv error");
        return;
    }
    
    printf("[P2] Przekazuję SIGUSR1 do P3\n");
    
    // Wysyłamy do kolejki P3
    if (msgsnd(msgid_p3, &msg, sizeof(int), 0) == -1) {
        perror("[P2] msgsnd error do P3");
    }
    kill(pid3, SIGUSR1);
}

// Handler P3
void p3_signal_handler(int sig) {
    printf("[P3] Odebrałem SIGUSR1 od P2\n");
    
    // Odczyt sygnału z kolejki
    msgsig msg;
    if (msgrcv(msgid_p3, &msg, sizeof(int), 1, 0) == -1) {
        perror("[P3] msgrcv error");
        return;
    }
    
    printf("[P3] Kończę działanie po odebraniu sygnału %d\n", msg.signal);
    exit(0);
}

void P1_signal_init() {
    signal(SIGUSR1, p1_signal_handler);
    signal(SIGTERM, SIG_IGN);
    signal(SIGTSTP, SIG_IGN);
    signal(SIGCONT, SIG_IGN);
}

void P2_signal_init() {
    signal(SIGUSR1, p2_signal_handler);
    signal(SIGTERM, SIG_IGN);
    signal(SIGTSTP, SIG_IGN);
    signal(SIGCONT, SIG_IGN);
}

void P3_signal_init() {
    signal(SIGUSR1, p3_signal_handler);
}

int main() {
    key_t key1 = ftok("p1", 65);
    key_t key2 = ftok("p2", 66);
    key_t key3 = ftok("p3", 67);
    
    msgid_p1 = msgget(key1, 0666 | IPC_CREAT);
    msgid_p2 = msgget(key2, 0666 | IPC_CREAT);
    msgid_p3 = msgget(key3, 0666 | IPC_CREAT);
    
    if ((pid1 = fork()) == 0) {
        P1_signal_init();
        while (1) pause();
    }
    else if ((pid2 = fork()) == 0) {
        P2_signal_init();
        while (1) pause();
    }
    else if ((pid3 = fork()) == 0) {
        P3_signal_init();
        while (1) pause();
    }
    else {
        signal(SIGUSR1, parent_signal_handler);
        while (1) pause();
    }
    return 0;
}
