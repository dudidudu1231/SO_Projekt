#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <unistd.h>

// Struktura dla kolejki komunikatów
typedef struct {
    long msg_type;
    int signal;
} msgsig;

int msgid_p1, msgid_p2, msgid_p3; // Osobne kolejki dla P1, P2, P3

// PID-y procesów
pid_t pid1, pid2, pid3;

// Handler rodzica
void parent_signal_handler(int sig) {
    printf("[PARENT] Otrzymałem sygnał %d\n", sig);
    
    // Tworzymy komunikat
    msgsig msg;
    msg.msg_type = 1;
    msg.signal = sig;
    
    // Wysyłamy do kolejki P1
    if (msgsnd(msgid_p1, &msg, sizeof(int), 0) == -1) {
        perror("[PARENT] msgsnd error do P1");
    }
    printf("[PARENT] Przekazuję SIGUSR1 do P1\n");
    kill(pid1, SIGUSR1);
}

// Handler P1
void p1_signal_handler(int sig) {
    printf("[P1] Odebrałem SIGUSR1 od rodzica\n");
    
    // Odczyt sygnału z kolejki
    msgsig msg;
    if (msgrcv(msgid_p1, &msg, sizeof(int), 1, 0) == -1) {
        perror("[P1] msgrcv error");
        return;
    }
    
    printf("[P1] Przekazuję SIGUSR1 do P2\n");
    
    // Wysyłamy do kolejki P2
    if (msgsnd(msgid_p2, &msg, sizeof(int), 0) == -1) {
        perror("[P1] msgsnd error do P2");
    }
    kill(pid2, SIGUSR1);
}

// Handler P2
void p2_signal_handler(int sig) {
    printf("[P2] Odebrałem SIGUSR1 od P1\n");
    
    // Odczyt sygnału z kolejki
    msgsig msg;
    if (msgrcv(msgid_p2, &msg, sizeof(int), 1, 0) == -1) {
        perror("[P2] msgrcv error");
        return;
    }
    
    printf("[P2] Przekazuję SIGUSR1 do P3\n");
    
    // Wysyłamy do kolejki P3
    if (msgsnd(msgid_p3, &msg, sizeof(int), 0) == -1) {
        perror("[P2] msgsnd error do P3");
    }
    kill(pid3, SIGUSR1);
}

// Handler P3
void p3_signal_handler(int sig) {
    printf("[P3] Odebrałem SIGUSR1 od P2\n");
    
    // Odczyt sygnału z kolejki
    msgsig msg;
    if (msgrcv(msgid_p3, &msg, sizeof(int), 1, 0) == -1) {
        perror("[P3] msgrcv error");
        return;
    }
    
    printf("[P3] Kończę działanie po odebraniu sygnału %d\n", msg.signal);
    exit(0);
}

void P1_signal_init() {
    signal(SIGUSR1, p1_signal_handler);
    signal(SIGTERM, SIG_IGN);
    signal(SIGTSTP, SIG_IGN);
    signal(SIGCONT, SIG_IGN);
}

void P2_signal_init() {
    signal(SIGUSR1, p2_signal_handler);
    signal(SIGTERM, SIG_IGN);
    signal(SIGTSTP, SIG_IGN);
    signal(SIGCONT, SIG_IGN);
}

void P3_signal_init() {
    signal(SIGUSR1, p3_signal_handler);
}

int main() {
    // Czyszczenie zasobów
    sem_unlink("/sem_2");
    sem_unlink("/sem_3");
    shm_unlink(SHM_NAME);
    
    // Kolejki komunikatów
    key_t key1 = ftok(".", 'A');
    key_t key2 = ftok(".", 'B');
    key_t key3 = ftok(".", 'C');
    
    msgid_p1 = msgget(key1, 0666 | IPC_CREAT);
    msgid_p2 = msgget(key2, 0666 | IPC_CREAT);
    msgid_p3 = msgget(key3, 0666 | IPC_CREAT);
    
    if (msgid_p1 == -1 || msgid_p2 == -1 || msgid_p3 == -1) {
        report_and_exit("msgget error", 1);
    }
    
    msgsignal = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if (msgsignal < 0) {
        report_and_exit("msgget (IPC_PRIVATE) error", 1);
    }

    // Semafory
    sem_2 = sem_open("/sem_2", O_CREAT | O_EXCL, 0666, 0);
    sem_3 = sem_open("/sem_3", O_CREAT | O_EXCL, 0666, 0);
    if (sem_2 == SEM_FAILED || sem_3 == SEM_FAILED) {
        report_and_exit("sem_open error", 1);
    }

    // Pamięć współdzielona
    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) {
        report_and_exit("shm_open error", 1);
    }
    if (ftruncate(shm_fd, ByteSize) == -1) {
        report_and_exit("ftruncate error", 1);
    }
    char *shared_memory = mmap(NULL, ByteSize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_memory == MAP_FAILED) {
        report_and_exit("mmap error", 1);
    }

    // Rejestracja handlera sygnałów w rodzicu
    struct sigaction sa_parent;
    memset(&sa_parent, 0, sizeof(sa_parent));
    sa_parent.sa_handler = parent_signal_handler;
    sigaction(SIGUSR1, &sa_parent, NULL);

    // Ignorowanie innych sygnałów w rodzicu
    for (int i = 1; i < 32; i++) {
        if (i == SIGKILL || i == SIGSTOP || i == SIGUSR1) continue;
        signal(i, SIG_IGN);
    }

    // Tworzenie procesów
    if ((pid1 = fork()) == 0) {
        P1_signal_init();
        while (1) pause();
    }
    
    if ((pid2 = fork()) == 0) {
        P2_signal_init();
        while (1) pause();
    }
    
    if ((pid3 = fork()) == 0) {
        P3_signal_init();
        while (1) pause();
    }
    
    // Rodzic czeka na zakończenie dzieci
    for (int i = 0; i < 3; i++) {
        wait(NULL);
    }

    // Sprzątanie zasobów
    sem_unlink("/sem_2");
    sem_unlink("/sem_3");
    shm_unlink(SHM_NAME);
    msgctl(msgid_p1, IPC_RMID, NULL);
    msgctl(msgid_p2, IPC_RMID, NULL);
    msgctl(msgid_p3, IPC_RMID, NULL);
    msgctl(msgsignal, IPC_RMID, NULL);

    printf("[Parent] Wszystkie procesy zakończone. Zasoby zwolnione.\n");
    return 0;
}
