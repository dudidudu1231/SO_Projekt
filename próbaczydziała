#include <fcntl.h>
#include <semaphore.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/msg.h>    // <-- Potrzebne do kolejek komunikatów
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <threads.h>
#include <unistd.h>

//======================================================
//  Ustawienia
//======================================================
#define FIFO_NAME "fifo_p1_p2"
#define BUFFER_SIZE 256

// Nazwy semaforów
#define SEM_NAME_1 "semaphore1"
#define SEM_NAME_2 "semaphore2"
#define SEM_NAME_3 "semaphore3"

//------------------------------------------------------
// Struktura do przesyłania sygnałów przez kolejki
//------------------------------------------------------
struct sig_buffer {
    long mtype;     // musi być > 0
    int  sigval;    // tutaj zapiszemy np. SIGTERM / SIGTSTP / SIGCONT
};

// Prosta funkcja do wysyłania sygnału do kolejki
void sendSignalMsg(int msqID, int sigval) {
    struct sig_buffer s;
    s.mtype  = 1;       // zawsze 1 (dowolne >0)
    s.sigval = sigval;
    if (msgsnd(msqID, &s, sizeof(s.sigval), 0) == -1) {
        perror("msgsnd error (signal)");
    }
}

// Prosta funkcja do odbierania sygnału z kolejki
int receiveSignalMsg(int msqID) {
    while (1) {
        struct sig_buffer s;
        ssize_t rc = msgrcv(msqID, &s, sizeof(s.sigval), 0, 0);
        if (rc == -1) {
            if (errno == EINTR) {
                // jeśli przerwano sygnałem i chcemy kontynuować
                continue;
            }
            perror("msgrcv error (signal)");
            return -1;
        }
        return s.sigval;
    }
}

//======================================================
//  Zmienne globalne
//======================================================
pid_t p1, p2, p3;      // PID-y potomnych
int pipe_fd[2];
int fd;                // deskryptor do FIFO
int blocked = 0;       // flaga "zablokowany" w P1/P2/P3
sem_t *sem_1, *sem_2, *sem_3;

// Kolejki komunikatów do sygnałów
int msgidSigParent;    // kolejka: P3 -> rodzic
int msgidSigP1;        // kolejka: rodzic -> P1  (a także P1 -> P2 -> P3 w łańcuchu)
int msgidSigP2;
int msgidSigP3;

//------------------------------------------------------
//  Struktura do danych w P1/P2/P3
//------------------------------------------------------
//  (nie potrzebujemy tu shared memory jak w oryginale - usuwamy.)

//======================================================
//  Pomocnicze
//======================================================
void report_and_exit(const char *msg) {
    perror(msg);
    exit(-1);
}

// Zamknięcia i usunięcia
void handle_exit(int process_number) {
    switch (process_number) {
      case 1:
        close(fd);
        unlink(FIFO_NAME);
        break;
      case 2:
        close(fd);
        close(pipe_fd[1]);
        break;
      case 3:
        close(pipe_fd[0]);
        break;
    }
    exit(0);
}

//======================================================
//  Obsługa sygnałów zewnętrznych w P3
//  (SIGTERM, SIGTSTP, SIGCONT) => kill(parent, SIGUSR1)
//  + kolejka do rodzica
//======================================================
static void process_external_signal(int sig_id) {
    printf("P3 [%d]: Otrzymalem zewnetrzny sygnal (%d)\n", getpid(), sig_id);

    // 1) Wyślij do kolejki "sig_id" => parent
    sendSignalMsg(msgidSigParent, sig_id);

    // 2) Wyślij SIGUSR1 do parent, żeby go wybudzić
    if (kill(getppid(), SIGUSR1) == -1) {
        report_and_exit("Failed to send SIGUSR1 to PM!");
    }
}

//======================================================
//  Handler w rodzicu na SIGUSR1 od P3
//======================================================
// Rodzic w tym handlerze odczytuje z kolejki msgidSigParent, jaki sygnał
// nadszedł (SIGTERM/SIGTSTP/SIGCONT), a potem "kaskadowo" rozsyła do P1->P2->P3.
static void process_main_sigusr1(int sig) {
    int val = receiveSignalMsg(msgidSigParent);
    if (val < 0) {
        // błąd msgrcv
        return;
    }
    printf("PM [%d]: Otrzymalem sygnal od P3 (%d), rozsyłam do P1->P2->P3\n", getpid(), val);

    // Wysyłamy do kolejki P1 informację "val"
    sendSignalMsg(msgidSigP1, val);

    // Budzimy P1 sygnałem SIGUSR1
    if (kill(p1, SIGUSR1) == -1) {
        report_and_exit("Failed to send SIGUSR1 to P1!");
    }
}

//======================================================
//  Funkcje "wykonania" sygnału w P1/P2/P3
//======================================================
static void execute_child_signal(int sig_id, int processNumber) {
    printf("P%d [%d]: Wykonuję sygnal %d\n", processNumber, getpid(), sig_id);

    switch (sig_id) {
      case SIGTSTP:
        blocked = 1;
        break;
      case SIGCONT:
        blocked = 0;
        break;
      case SIGTERM:
        handle_exit(processNumber);
        break;
      default:
        // Inne sygnały ignorujemy
        break;
    }
}

//======================================================
//  Handler w P1/P2/P3 na SIGUSR1 (łańcuch sygnałów)
//======================================================
static void process_child_signal(int sig) {
    // Rozpoznaj, który to proces
    int process_number = (getpid() == p1) ? 1 :
                         (getpid() == p2) ? 2 : 3;

    // 1) Odczytaj z "własnej" kolejki, jaki sygnał
    int val;
    if (process_number == 1) {
        val = receiveSignalMsg(msgidSigP1);
        printf("P1 [%d]: Otrzymalem sygnal SIGUSR1 od PM\n", getpid());
    } else if (process_number == 2) {
        val = receiveSignalMsg(msgidSigP2);
        printf("P2 [%d]: Otrzymalem sygnal SIGUSR1 od P1\n", getpid());
    } else {
        val = receiveSignalMsg(msgidSigP3);
        printf("P3 [%d]: Otrzymalem sygnal SIGUSR1 od P2\n", getpid());
    }
    if (val < 0) return; // błąd msgrcv

    printf("P%d [%d]: Sygnal do wykonania = %d\n", process_number, getpid(), val);

    // 2) Jeśli P1 lub P2 => przekaz dalej w łańcuchu
    if (process_number == 1) {
        // wysyłamy do kolejki P2
        sendSignalMsg(msgidSigP2, val);
        // kill P2
        if (kill(p2, SIGUSR1) == -1) {
            report_and_exit("Failed to send SIGUSR1 to P2!");
        }
    } else if (process_number == 2) {
        // wysyłamy do kolejki P3
        sendSignalMsg(msgidSigP3, val);
        // kill P3
        if (kill(p3, SIGUSR1) == -1) {
            report_and_exit("Failed to send SIGUSR1 to P3!");
        }
    }
    // 3) Wykonaj sygnał
    execute_child_signal(val, process_number);
}

//======================================================
//  Proces 1 (producent): czyta dane, wysyła do P2 (FIFO)
//======================================================
void process1() {
    // Otwieranie FIFO w trybie zapisu
    fd = open(FIFO_NAME, O_WRONLY);
    if (fd == -1) {
        unlink(FIFO_NAME);
        report_and_exit("Unable to open fifo (P1)");
    }

    // Ustaw maskę sygnałów tak, by tylko SIGUSR1 był dozwolony
    sigset_t blacklist;
    sigfillset(&blacklist);
    sigdelset(&blacklist, SIGUSR1);
    sigprocmask(SIG_SETMASK, &blacklist, NULL);

    // Obsługa SIGUSR1
    signal(SIGUSR1, process_child_signal);

    int exitFlag = 0;
    char filename[BUFFER_SIZE];
    char buffer[BUFFER_SIZE];

    while (!exitFlag) {
        while (blocked) {
            // Busy loop
        }

        printf("========MENU========\n");
        printf("Jak chcesz wczytac dane?\n");
        printf("1. Z klawiatury\n");
        printf("2. Z pliku\n");
        printf("Wybor: ");
        fflush(stdout);

        int input;
        if (scanf("%d", &input) != 1) {
            int c; while ((c=getchar())!='\n' && c!=EOF){}
            printf("P1 [%d]: Niepoprawna opcja (nie liczba).\n", getpid());
            continue;
        }
        // usunięcie śmieci z bufora
        int c; while ((c=getchar())!='\n' && c!=EOF){}

        switch (input) {
          case 1: {
            printf("P1 [%d]: Podaj dane wejsciowe: ", getpid());
            fflush(stdout);
            if (!fgets(buffer, BUFFER_SIZE, stdin)) {
                // błąd albo EOF
                continue;
            }
            printf("P1 [%d]: Wyslano do P2: %s", getpid(), buffer);
            write(fd, buffer, BUFFER_SIZE);
            while (blocked) {}
            sem_post(sem_2);   // sygnalizuj P2
            sem_wait(sem_1);   // czekaj na P3
            break;
          }
          case 2: {
            printf("P1 [%d]: Podaj nazwe pliku: ", getpid());
            fflush(stdout);
            if (!fgets(filename, sizeof(filename), stdin)) {
                fprintf(stderr, "Blad odczytu nazwy pliku\n");
                continue;
            }
            filename[strcspn(filename, "\n")] = '\0';

            FILE *fp = fopen(filename, "r");
            if (!fp) {
                perror("Nie udalo sie otworzyc pliku");
                continue;
            }
            while (fgets(buffer, BUFFER_SIZE, fp)) {
                printf("P1 [%d]: Wyslano do P2: %s", getpid(), buffer);
                write(fd, buffer, BUFFER_SIZE);

                while (blocked) {}
                sem_post(sem_2);
                sem_wait(sem_1);
            }
            fclose(fp);
            break;
          }
          default:
            printf("P1 [%d]: Niepoprawna opcja.\n", getpid());
            exitFlag = 1;
            break;
        }
    }

    close(fd);
    unlink(FIFO_NAME);
    exit(0);
}

//======================================================
//  Proces 2 (konsument/producent):
//   - odbiera dane z FIFO
//   - liczy długość
//   - wysyła do P3 przez pipe
//======================================================
void process2() {
    // Maska sygnałów
    sigset_t blacklist;
    sigfillset(&blacklist);
    sigdelset(&blacklist, SIGUSR1);
    sigprocmask(SIG_SETMASK, &blacklist, NULL);

    signal(SIGUSR1, process_child_signal);

    // Otwieranie FIFO w trybie odczytu
    fd = open(FIFO_NAME, O_RDONLY);
    if (fd == -1) {
        report_and_exit("Unable to open fifo (P2)!");
    }
    // Zamykamy nieużywany koniec do ODCZYTU w pipe (P2 -> P3 = pipe_fd[1] do zapisu)
    close(pipe_fd[0]);

    char buffer[BUFFER_SIZE] = {0};
    char output[BUFFER_SIZE] = {0};

    while (1) {
        sem_wait(sem_2);
        if (read(fd, buffer, BUFFER_SIZE) > 0) {
            int length = strlen(buffer);
            if (length>0 && buffer[length-1]=='\n') {
                buffer[length-1] = '\0';
                length = strlen(buffer);
            }

            printf("P2 [%d]: Odczytano: %s\n", getpid(), buffer);

            snprintf(output, BUFFER_SIZE, "%s %d\n", buffer, length);

            printf("P2 [%d]: Wyslano do P3: %s", getpid(), output);
            write(pipe_fd[1], output, strlen(output));

            memset(buffer, 0, BUFFER_SIZE);
            memset(output, 0, BUFFER_SIZE);

            while (blocked) {}
            sem_post(sem_3);
        }
    }

    close(fd);
    close(pipe_fd[1]);
}

//======================================================
//  Proces 3 (konsument):
//   - odbiera dane z pipe
//   - wyświetla
//   - wysyła semafor do P1
//   - obsługuje zewn. sygnały (SIGTERM/TSTP/CONT)
//======================================================
void process3() {
    // Maska sygnałów: pozwalamy SIGTERM, SIGTSTP, SIGCONT, SIGUSR1
    sigset_t blacklist;
    sigfillset(&blacklist);
    // Usuwamy z maski sygnały, które obsługujemy
    sigdelset(&blacklist, SIGTERM);
    sigdelset(&blacklist, SIGTSTP);
    sigdelset(&blacklist, SIGCONT);
    sigdelset(&blacklist, SIGUSR1);
    sigprocmask(SIG_SETMASK, &blacklist, NULL);

    // Obsługa SIGUSR1 (łańcuch)
    signal(SIGUSR1, process_child_signal);

    // Obsługa sygnałów zewnętrznych
    signal(SIGTERM, process_external_signal);
    signal(SIGTSTP, process_external_signal);
    signal(SIGCONT, process_external_signal);

    // Zamykamy nieużywany koniec zapisu w pipe
    close(pipe_fd[1]);

    char buffer[BUFFER_SIZE];

    while (1) {
        sem_wait(sem_3);
        if (read(pipe_fd[0], buffer, BUFFER_SIZE) > 0) {
            printf("P3 [%d]: %s", getpid(), buffer);
            while (blocked) {}
            sem_post(sem_1);
            memset(buffer, 0, BUFFER_SIZE);
        }
    }

    close(pipe_fd[0]);
}

//======================================================
//   main (rodzic, PM)
//======================================================
int main() {
    // 1) Usuwamy stare semafory
    sem_unlink(SEM_NAME_1);
    sem_unlink(SEM_NAME_2);
    sem_unlink(SEM_NAME_3);

    // Tworzymy semafory
    sem_1 = sem_open(SEM_NAME_1, O_CREAT | O_EXCL, 0666, 0);
    sem_2 = sem_open(SEM_NAME_2, O_CREAT | O_EXCL, 0666, 0);
    sem_3 = sem_open(SEM_NAME_3, O_CREAT | O_EXCL, 0666, 0);
    if (sem_1==SEM_FAILED || sem_2==SEM_FAILED || sem_3==SEM_FAILED) {
        report_and_exit("sem_open error");
    }

    // Tworzymy FIFO
    unlink(FIFO_NAME);
    if (mkfifo(FIFO_NAME, 0666) == -1) {
        perror("mkfifo error");
        return 0;
    }

    // Tworzymy pipe
    if (pipe(pipe_fd) == -1) {
        report_and_exit("pipe creation error");
    }

    // 2) Kolejki komunikatów do sygnałów
    //    - P3 -> parent (msgidSigParent)
    //    - parent -> P1 (msgidSigP1)
    //    - łańcuch: P1 -> P2 -> P3
    key_t key_s_parent = ftok(".", 'P');  // np. 'P'
    key_t key_s_p1     = ftok(".", '1');
    key_t key_s_p2     = ftok(".", '2');
    key_t key_s_p3     = ftok(".", '3');

    msgidSigParent = msgget(key_s_parent, 0666 | IPC_CREAT);
    msgidSigP1     = msgget(key_s_p1,     0666 | IPC_CREAT);
    msgidSigP2     = msgget(key_s_p2,     0666 | IPC_CREAT);
    msgidSigP3     = msgget(key_s_p3,     0666 | IPC_CREAT);
    if (msgidSigParent==-1 || msgidSigP1==-1 || msgidSigP2==-1 || msgidSigP3==-1) {
        report_and_exit("msgget (signal) error");
    }

    // 3) Blokujemy wszystkie sygnały poza SIGUSR1 w rodzicu
    sigset_t blacklist;
    sigfillset(&blacklist);
    sigdelset(&blacklist, SIGUSR1);
    sigprocmask(SIG_SETMASK, &blacklist, NULL);

    // 4) Ustawiamy handler SIGUSR1 w rodzicu
    signal(SIGUSR1, process_main_sigusr1);

    // 5) Tworzymy procesy
    p1 = fork();
    if (p1 == 0) {
        process1();
        exit(0);
    } else if (p1 < 0) {
        report_and_exit("fork P1 error");
    }

    p2 = fork();
    if (p2 == 0) {
        process2();
        exit(0);
    } else if (p2 < 0) {
        report_and_exit("fork P2 error");
    }

    p3 = fork();
    if (p3 == 0) {
        process3();
        exit(0);
    } else if (p3 < 0) {
        report_and_exit("fork P3 error");
    }

    // 6) Rodzic czeka na potomnych
    waitpid(p2, NULL, 0);
    waitpid(p3, NULL, 0);
    waitpid(p1, NULL, 0);

    // Sprzątanie
    sem_unlink(SEM_NAME_1);
    sem_unlink(SEM_NAME_2);
    sem_unlink(SEM_NAME_3);
    sem_close(sem_1);
    sem_close(sem_2);
    sem_close(sem_3);

    unlink(FIFO_NAME);

    msgctl(msgidSigParent, IPC_RMID, NULL);
    msgctl(msgidSigP1,     IPC_RMID, NULL);
    msgctl(msgidSigP2,     IPC_RMID, NULL);
    msgctl(msgidSigP3,     IPC_RMID, NULL);

    printf("PM [%d]: Zakonczono dzialanie programu!\n", getpid());
    return 0;
}
