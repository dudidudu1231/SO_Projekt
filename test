#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <semaphore.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/msg.h>
#include <signal.h>

#define FIFO_NAME "/home/filip/skrypty_shellowe/projekt/my_fifo"
#define SHM_NAME "/shared_memory"
#define ByteSize 256

// Message Queue Definitions
struct msgbuf {
    long mtype;            // Message type
    char mtext[ByteSize];  // Message content
};

int msgid;  // Message queue ID

// Semaphore Definitions
sem_t *sem_1, *sem_2, *sem_3;
char buffer[ByteSize];

// Report errors and exit
void report_and_exit(const char *msg, int exit_code) {
    perror(msg);
    exit(exit_code);
}

// Character counting function
int zlicz_znaki(const char *str) {
    int count = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] != '\n' && str[i] != '\r') count++;
    }
    return count;
}

// Signal Handler for P3
void handle_signal(int sig) {
    struct msgbuf message;
    message.mtype = 1;  // Message type 1 for signals
    sprintf(message.mtext, "P3 received signal: %d", sig);

    // Send message to queue
    if (msgsnd(msgid, &message, strlen(message.mtext) + 1, 0) == -1) {
        perror("msgsnd error");
    }

    // Notify parent process via a signal
    kill(getppid(), SIGUSR1);
}

// Parent Process Signal Handler
void handle_parent_signal(int sig) {
    struct msgbuf message;

    // Read the message from the queue
    if (msgrcv(msgid, &message, sizeof(message.mtext), 1, 0) == -1) {
        perror("msgrcv error");
    }

    printf("Parent Process: %s\n", message.mtext);

    // Notify P1
    kill(0, SIGUSR2);  // Broadcast to all processes in the group
}

// Process P1
void P1() {
    signal(SIGUSR2, handle_signal);  // Receive notification
    printf("P1: Waiting for messages...\n");

    struct msgbuf message;
    while (1) {
        if (msgrcv(msgid, &message, sizeof(message.mtext), 1, 0) == -1) {
            perror("msgrcv error");
            break;
        }

        printf("P1 received: %s\n", message.mtext);

        // Notify P2
        kill(0, SIGUSR2);  // Notify the next process
    }
}

// Process P2
void P2(char *shared_memory) {
    signal(SIGUSR2, handle_signal);  // Receive notification
    printf("P2: Waiting for messages...\n");

    struct msgbuf message;
    while (1) {
        if (msgrcv(msgid, &message, sizeof(message.mtext), 1, 0) == -1) {
            perror("msgrcv error");
            break;
        }

        printf("P2 received: %s\n", message.mtext);

        // Notify P3
        kill(0, SIGUSR2);  // Notify the next process
    }
}

// Process P3
void P3(char *shared_memory) {
    signal(SIGUSR1, handle_signal);  // Handle incoming signals
    printf("P3: Ready to receive signals...\n");

    while (1) {
        pause();  // Wait for a signal
    }
}

int main() {
    // Setup signal handlers
    signal(SIGUSR1, handle_parent_signal);

    // Create message queue
    msgid = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
    if (msgid == -1) {
        report_and_exit("msgget error", 1);
    }

    // Unlink existing semaphores and shared memory
    sem_unlink("/sem_1");
    sem_unlink("/sem_2");
    sem_unlink("/sem_3");
    shm_unlink(SHM_NAME);

    // Create new semaphores
    sem_1 = sem_open("/sem_1", O_CREAT | O_EXCL, 0666, 0);
    sem_2 = sem_open("/sem_2", O_CREAT | O_EXCL, 0666, 0);
    sem_3 = sem_open("/sem_3", O_CREAT | O_EXCL, 0666, 0);

    if (sem_1 == SEM_FAILED || sem_2 == SEM_FAILED || sem_3 == SEM_FAILED) {
        report_and_exit("sem_open error", 1);
    }

    // Create shared memory
    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) {
        report_and_exit("shm_open error", 1);
    }

    if (ftruncate(shm_fd, ByteSize) == -1) {
        report_and_exit("ftruncate error", 1);
    }

    char *shared_memory = mmap(NULL, ByteSize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_memory == MAP_FAILED) {
        report_and_exit("mmap error", 1);
    }

    // Fork processes
    pid_t pid1 = fork();

    if (pid1 == 0) {
        // Child process P1
        P1();
        exit(0);
    }

    pid_t pid2 = fork();

    if (pid2 == 0) {
        // Child process P2
        P2(shared_memory);
        exit(0);
    }

    pid_t pid3 = fork();

    if (pid3 == 0) {
        // Child process P3
        P3(shared_memory);
        exit(0);
    }

    // Parent waits for children
    wait(NULL);
    wait(NULL);
    wait(NULL);

    // Cleanup
    sem_unlink("/sem_1");
    sem_unlink("/sem_2");
    sem_unlink("/sem_3");
    shm_unlink(SHM_NAME);
    msgctl(msgid, IPC_RMID, NULL);

    return 0;
}

