#define _POSIX_C_SOURCE 200809L
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <semaphore.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/msg.h>
#include <sys/ipc.h>

/* 
    *******************************************************
    *                 USTAWIENIA / STAŁE                  *
    *******************************************************
*/

#define FIFO_NAME   "/tmp/my_fifo_demo"   /* dowolna ścieżka, np. w /tmp */
#define SHM_NAME    "/shared_memory_demo" /* nazwa segmentu pamięci dzielonej */
#define ByteSize    256

/*
   Kolejka "done" (P3 -> P1)
   -------------------------
   Proces P3 wysyła potwierdzenie "done" do P1, aby P1 wiedział, że 
   linijka przekazana przez FIFO została przetworzona przez P3.
*/
struct msg_data {
    long msg_type;         /* musi być >0 */
    char msg_text[20];
};

/* Id kolejki "done" */
static int msgid_p3_p1 = -1;

/*
   Trzy kolejki do sygnałów parent <-> child
   -----------------------------------------
   Każdy proces (P1, P2, P3) ma własną kolejkę do komunikacji z rodzicem.
   - Dzieci używają mtype=1, by wysłać sygnał do rodzica,
   - Rodzic używa mtype=2, by wysłać sygnał do danego dziecka.
*/
typedef struct {
    long mtype;   /* 1=child->parent, 2=parent->child */
    int  signal;
} sigmsg_t;

static int msgid_p1 = -1;  /* parent <-> P1 */
static int msgid_p2 = -1;  /* parent <-> P2 */
static int msgid_p3 = -1;  /* parent <-> P3 */

/*
   Semafory do synchronizacji P2 <-> P3
   ------------------------------------
   - sem_3: P2 -> P3 (po wpisaniu liczby znaków do pamięci dzielonej)
   - sem_2: P3 -> P2 (po przetworzeniu/odczytaniu liczby)
*/
static sem_t *sem_2 = NULL;
static sem_t *sem_3 = NULL;

/*
   Globalne PID-y procesów (uzupełniane w main) 
   do łańcuchowego kill() 
*/
static pid_t pid1 = -1, pid2 = -1, pid3 = -1;

/* Bufor pomocniczy do czytania linii z klawiatury/plików */
static char buffer[ByteSize];

/* =======================================================
   Pomocnicza funkcja do zgłaszania błędów i kończenia.
   ======================================================= */
static void die(const char *msg) {
    perror(msg);
    exit(EXIT_FAILURE);
}

/* =======================================================
   Funkcja do liczenia znaków (bez '\n' i '\r').
   ======================================================= */
static int zlicz_znaki(const char *str) {
    int count = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] != '\n' && str[i] != '\r') {
            count++;
        }
    }
    return count;
}

/* *******************************************************************
   *                    FUNKCJE OBSŁUGI SYGNAŁÓW                      *
   *******************************************************************
   Tutaj definiujemy handlery sygnałów (dla P1, P2, P3 oraz rodzica).
   Obsługa jest rozbita tak, by:
   - P3 miał *dwa* rodzaje sygnałów (z terminala i od rodzica)
   - P1, P2, P3 przy sygnale od rodzica korzystały z łańcucha:
     P1 -> obudź P2 -> (P2 odbierze sygnał) -> obudź P3 -> ...
   - Rodzic, gdy dostanie SIGUSR1, wie, że P3 wysłał do niego wiadomość 
     (z terminala) w kolejce p3->parent.
*/

/* ------------------ P3: handler sygnałów z terminala ------------- */
static void p3_terminal_handler(int sig) {
    printf("[P3, PID=%d] Otrzymałem sygnał z terminala: %d\n", getpid(), sig);

    /* Wyślij komunikat child->parent (mtype=1) do kolejki msgid_p3 */
    sigmsg_t msg;
    msg.mtype  = 1;
    msg.signal = sig;
    if (msgsnd(msgid_p3, &msg, sizeof(msg.signal), 0) == -1) {
        perror("[P3] msgsnd (child->parent)");
    }

    /* Obudź rodzica przez kill(SIGUSR1) */
    kill(getppid(), SIGUSR1);

    /* SIGTSTP/SIGCONT: aby rzeczywiście zatrzymać/wznowić P3, 
       przywracamy domyślną akcję i natychmiast podnosimy sygnał. */
    if (sig == SIGTSTP || sig == SIGCONT) {
        signal(sig, SIG_DFL);
        raise(sig);
    }
}

/* ------------------ P3: handler sygnałów od rodzica (łańcuch) ----- */
static void p3_parent_handler(int sig) {
    (void)sig;  /* wiemy, że to SIGUSR1 */

    /* Odczytujemy z kolejki parent->child (msgid_p3, mtype=2) */
    sigmsg_t msg;
    if (msgrcv(msgid_p3, &msg, sizeof(msg.signal), 2, 0) == -1) {
        perror("[P3] msgrcv (parent->child)");
        return;
    }
    printf("[P3, PID=%d] Otrzymałem od rodzica sygnał %d (łańcuch)\n",
           getpid(), msg.signal);

    /* Wykonujemy sygnał: np. SIGTERM => koniec */
    switch (msg.signal) {
        case SIGTERM:
            printf("[P3] Kończę działanie po SIGTERM.\n");
            exit(0);
            break;

        case SIGTSTP:
            printf("[P3] Zatrzymuję się (SIGTSTP).\n");
            signal(SIGTSTP, SIG_DFL);
            raise(SIGTSTP);
            break;

        case SIGCONT:
            printf("[P3] Wznawiam się (SIGCONT).\n");
            signal(SIGCONT, SIG_DFL);
            raise(SIGCONT);
            break;

        case SIGINT:
            /* Przykład: SIGINT też można potraktować jak SIGTERM */
            printf("[P3] Kończę działanie po SIGINT.\n");
            exit(0);
            break;

        default:
            printf("[P3] (Uwaga) Sygnał %d nie jest osobno obsłużony.\n", msg.signal);
            break;
    }
}

/* --------------- P2: handler sygnałów od rodzica (łańcuch) -------- */
static void p2_parent_handler(int sig) {
    (void)sig;  /* SIGUSR1 */

    /* Odczyt z msgid_p2, parent->child (mtype=2) */
    sigmsg_t msg;
    if (msgrcv(msgid_p2, &msg, sizeof(msg.signal), 2, 0) == -1) {
        perror("[P2] msgrcv (parent->child)");
        return;
    }
    printf("[P2, PID=%d] Otrzymałem od rodzica sygnał %d. Powiadamiam P3...\n",
           getpid(), msg.signal);

    /* Budzimy P3 => kill(pid3, SIGUSR1) */
    kill(pid3, SIGUSR1);

    /* Teraz P2 sam wykonuje sygnał */
    switch (msg.signal) {
        case SIGTERM:
            printf("[P2] Kończę działanie po SIGTERM.\n");
            exit(0);
            break;

        case SIGTSTP:
            printf("[P2] Zatrzymuję się (SIGTSTP).\n");
            signal(SIGTSTP, SIG_DFL);
            raise(SIGTSTP);
            break;

        case SIGCONT:
            printf("[P2] Wznawiam się (SIGCONT).\n");
            signal(SIGCONT, SIG_DFL);
            raise(SIGCONT);
            break;

        case SIGINT:
            /* przykładowo potraktujemy jak SIGTERM */
            printf("[P2] Kończę działanie po SIGINT.\n");
            exit(0);
            break;

        default:
            printf("[P2] (Uwaga) Sygnał %d nie jest osobno obsłużony.\n", msg.signal);
            break;
    }
}

/* --------------- P1: handler sygnałów od rodzica (łańcuch) -------- */
static void p1_parent_handler(int sig) {
    (void)sig;  /* SIGUSR1 */

    /* Odczyt z msgid_p1, parent->child (mtype=2) */
    sigmsg_t msg;
    if (msgrcv(msgid_p1, &msg, sizeof(msg.signal), 2, 0) == -1) {
        perror("[P1] msgrcv (parent->child)");
        return;
    }
    printf("[P1, PID=%d] Otrzymałem od rodzica sygnał %d. Powiadamiam P2...\n",
           getpid(), msg.signal);

    /* Najpierw budzimy P2 */
    kill(pid2, SIGUSR1);

    /* Wykonujemy sygnał w P1 */
    switch (msg.signal) {
        case SIGTERM:
            printf("[P1] Kończę działanie po SIGTERM.\n");
            exit(0);
            break;

        case SIGTSTP:
            printf("[P1] Zatrzymuję się (SIGTSTP).\n");
            signal(SIGTSTP, SIG_DFL);
            raise(SIGTSTP);
            break;

        case SIGCONT:
            printf("[P1] Wznawiam się (SIGCONT).\n");
            signal(SIGCONT, SIG_DFL);
            raise(SIGCONT);
            break;

        case SIGINT:
            printf("[P1] Kończę działanie po SIGINT.\n");
            exit(0);
            break;

        default:
            printf("[P1] (Uwaga) Sygnał %d nie jest osobno obsłużony.\n", msg.signal);
            break;
    }
}

/* --------------- Parent: handler SIGUSR1 (od P3) ------------------- */
static void parent_sigusr1_handler(int sig) {
    (void)sig;  /* SIGUSR1 */

    /* Odczyt sygnału z kolejki child->parent (msgid_p3, mtype=1) */
    sigmsg_t msg;
    if (msgrcv(msgid_p3, &msg, sizeof(msg.signal), 1, 0) == -1) {
        perror("[Parent] msgrcv (child->parent)");
        return;
    }
    int received_signal = msg.signal;
    printf("[Parent] Otrzymałem sygnał %d od P3 (z terminala)\n", received_signal);

    /* Rozsyłamy do P1, P2, P3 przez ich kolejki (mtype=2) */
    msg.mtype = 2;
    if (msgsnd(msgid_p1, &msg, sizeof(msg.signal), 0) == -1)
        perror("[Parent] msgsnd -> P1");
    if (msgsnd(msgid_p2, &msg, sizeof(msg.signal), 0) == -1)
        perror("[Parent] msgsnd -> P2");
    if (msgsnd(msgid_p3, &msg, sizeof(msg.signal), 0) == -1)
        perror("[Parent] msgsnd -> P3");

    /* Budzimy P1, by zaczął łańcuch (P1->P2->P3) */
    kill(pid1, SIGUSR1);
}

/* ********************************************************************
   *                           KOD PROCESÓW                            *
   ********************************************************************/

/* ------------------------------- P1 -------------------------------- */
static void P1(void) {
    /* Rejestrujemy handler do sygnałów łańcuchowych */
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = p1_parent_handler;
    sigaction(SIGUSR1, &sa, NULL);

    /* Ignorujemy sygnały terminalowe (obsługuje je P3) */
    signal(SIGINT,  SIG_IGN);
    signal(SIGTERM, SIG_IGN);
    signal(SIGTSTP, SIG_IGN);
    signal(SIGCONT, SIG_IGN);

    /* Tworzymy FIFO do zapisu */
    (void)unlink(FIFO_NAME);  
    if (mkfifo(FIFO_NAME, 0666) == -1 && errno != EEXIST) {
        die("mkfifo (P1) error");
    }
    int fd = open(FIFO_NAME, O_WRONLY);
    if (fd < 0) {
        die("open FIFO (P1) error");
    }

    /* Proste menu tekstowe */
    while (1) {
        printf("\n[P1] Menu:\n");
        printf("1. Czytaj z klawiatury (koniec: '.')\n");
        printf("2. Czytaj z pliku (do EOF)\n");
        printf("Wybierz opcję: ");
        fflush(stdout);

        int choice;
        if (scanf("%d", &choice) != 1) {
            /* Czyszczenie bufora w razie błędnego wczytania */
            int c;
            while ((c = getchar()) != '\n' && c != EOF) {}
            printf("[P1] Nieprawidłowy wybór.\n");
            continue;
        }
        /* Wyrzucenie reszty linii, by nie wpływała na dalsze fgets */
        {
            int c;
            while ((c = getchar()) != '\n' && c != EOF) {}
        }

        if (choice == 1) {
            /* --- Czytanie z klawiatury --- */
            while (1) {
                printf("[P1] Wpisz tekst ('.' kończy): ");
                fflush(stdout);

                char *ret = fgets(buffer, ByteSize, stdin);
                if (!ret) {
                    if (feof(stdin)) {
                        printf("[P1] EOF na stdin.\n");
                    } else {
                        perror("[P1] Błąd odczytu stdin");
                    }
                    break; /* powrót do menu */
                }
                /* Usuwamy \n z końca, by móc sprawdzać "." */
                buffer[strcspn(buffer, "\n")] = '\0';

                /* Sprawdzamy, czy to kropka (koniec) */
                if (strcmp(buffer, ".") == 0) {
                    printf("[P1] Koniec wczytywania z klawiatury.\n");
                    break;
                }

                /* Dodajemy \n na końcu, żeby P2 widział koniec linii */
                size_t len = strlen(buffer);
                buffer[len]   = '\n';
                buffer[len+1] = '\0';

                /* Zapis do FIFO (powtarzamy w razie EINTR) */
                ssize_t wret;
                do {
                    wret = write(fd, buffer, len+1);
                } while (wret == -1 && errno == EINTR);
                if (wret < 0) {
                    perror("[P1] write FIFO error");
                    break;
                }

                /* Czekamy na "done" od P3 (msgrcv) */
                struct msg_data m;
                if (msgrcv(msgid_p3_p1, &m, sizeof(m.msg_text), 1, 0) == -1) {
                    if (errno == EINTR) {
                        continue; /* jeśli przerwane sygnałem, powtarzamy */
                    }
                    perror("[P1] msgrcv p3->p1");
                    break;
                }
                /* Otrzymaliśmy potwierdzenie "done" */
            }
        }
        else if (choice == 2) {
            /* --- Czytanie z pliku --- */
            char filename[256];
            printf("[P1] Podaj nazwę pliku: ");
            fflush(stdout);
            if (!fgets(filename, sizeof(filename), stdin)) {
                fprintf(stderr, "[P1] Błąd odczytu nazwy pliku.\n");
                continue;
            }
            filename[strcspn(filename, "\n")] = '\0';

            FILE *file = fopen(filename, "r");
            if (!file) {
                perror("[P1] Nie można otworzyć pliku");
                continue;
            }

            while (1) {
                /* Czytamy jedną linię z pliku */
                char *p = fgets(buffer, ByteSize, file);
                if (!p) {
                    if (!feof(file)) {
                        perror("[P1] Błąd odczytu pliku");
                    }
                    printf("[P1] Koniec pliku.\n");
                    break;
                }
                printf("[P1] Wczytano z pliku: %s", buffer);

                size_t toWrite = strlen(buffer);
                /* Zapis do FIFO */
                ssize_t wret;
                do {
                    wret = write(fd, buffer, toWrite);
                } while (wret == -1 && errno == EINTR);
                if (wret < 0) {
                    perror("[P1] write FIFO error");
                    break;
                }

                /* Czekamy na "done" od P3 */
                struct msg_data m;
                if (msgrcv(msgid_p3_p1, &m, sizeof(m.msg_text), 1, 0) == -1) {
                    if (errno == EINTR) {
                        continue;
                    }
                    perror("[P1] msgrcv p3->p1");
                    break;
                }
            }
            fclose(file);
        }
        else {
            printf("[P1] Nieprawidłowy wybór.\n");
        }
    }

    close(fd);
    printf("[P1] Kończę działanie.\n");
    fflush(stdout);
    exit(EXIT_SUCCESS);
}

/* ------------------------------- P2 -------------------------------- */
static void P2(char *shared_memory) {
    /* Handler na SIGUSR1 od rodzica (łańcuch) */
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = p2_parent_handler;
    sigaction(SIGUSR1, &sa, NULL);

    /* Ignorujemy sygnały terminalowe w P2 (obsługuje je P3) */
    signal(SIGINT,  SIG_IGN);
    signal(SIGTERM, SIG_IGN);
    signal(SIGTSTP, SIG_IGN);
    signal(SIGCONT, SIG_IGN);

    /* Otwieramy FIFO do odczytu */
    int fd = open(FIFO_NAME, O_RDONLY);
    if (fd < 0) {
        die("open FIFO (P2) error");
    }
    FILE *f = fdopen(fd, "r");
    if (!f) {
        die("fdopen (P2) error");
    }

    while (1) {
        /* Odczyt jednej linii z FIFO */
        char *res = fgets(buffer, ByteSize, f);
        if (!res) {
            if (feof(f)) {
                printf("[P2] Koniec FIFO (EOF)\n");
            } else {
                perror("[P2] błąd fgets FIFO");
            }
            break;
        }
        printf("[P2] Dane odczytane z FIFO: %s", buffer);

        /* Liczymy znaki i przekazujemy do pamięci dzielonej */
        int ilosc = zlicz_znaki(buffer);
        sprintf(shared_memory, "%d", ilosc);
        printf("[P2] Ilość znaków: %d => przekazuję do P3\n", ilosc);

        /* Poinformuj P3 przez sem_post(sem_3) */
        if (sem_post(sem_3) == -1 && errno != EINTR) {
            perror("[P2] sem_post(sem_3)");
            break;
        }

        /* Czekamy, aż P3 skończy -> sem_wait(sem_2) */
        if (sem_wait(sem_2) == -1 && errno != EINTR) {
            perror("[P2] sem_wait(sem_2)");
            break;
        }
    }

    fclose(f);
    printf("[P2] Kończę działanie.\n");
    fflush(stdout);
    exit(EXIT_SUCCESS);
}

/* ------------------------------- P3 -------------------------------- */
static void P3(char *shared_memory) {
    /* Dwa rodzaje sygnałów: 
       - z terminala => p3_terminal_handler,
       - od rodzica => p3_parent_handler 
    */
    {
        struct sigaction sa_term; /* sygnały terminala */
        memset(&sa_term, 0, sizeof(sa_term));
        sa_term.sa_handler = p3_terminal_handler;
        sigaction(SIGINT,  &sa_term, NULL);
        sigaction(SIGTERM, &sa_term, NULL);
        sigaction(SIGTSTP, &sa_term, NULL);
        sigaction(SIGCONT, &sa_term, NULL);
    }
    {
        struct sigaction sa_parent; /* sygnały łańcuchowe od rodzica */
        memset(&sa_parent, 0, sizeof(sa_parent));
        sa_parent.sa_handler = p3_parent_handler;
        sigaction(SIGUSR1, &sa_parent, NULL);
    }

    while (1) {
        /* Czekamy na sem_3 od P2 (sygnalizuje gotowość w pamięci dzielonej) */
        if (sem_wait(sem_3) == -1 && errno != EINTR) {
            perror("[P3] sem_wait(sem_3)");
            break;
        }

        /* Odczyt z pamięci dzielonej */
        printf("[P3] Dane odczytane z PD: %s\n", shared_memory);
        printf("--------------------------------\n");

        /* sygnalizujemy P2 (sem_2) */
        if (sem_post(sem_2) == -1 && errno != EINTR) {
            perror("[P3] sem_post(sem_2)");
            break;
        }

        /* Wysyłamy "done" do P1 (uwalnia P1 z msgrcv) */
        struct msg_data m;
        m.msg_type = 1;  /* cokolwiek > 0 */
        strcpy(m.msg_text, "done");
        if (msgsnd(msgid_p3_p1, &m, sizeof(m.msg_text), 0) == -1) {
            perror("[P3] msgsnd p3->p1");
        }
    }

    printf("[P3] Kończę działanie.\n");
    fflush(stdout);
    exit(EXIT_SUCCESS);
}

/* ********************************************************************
   *                           MAIN (Rodzic)                           *
   ********************************************************************
   1. Usuwa stare semafory, kolejki, FIFO, by uniknąć konfliktów.
   2. Tworzy kolejki, semafory, pamięć dzieloną.
   3. Ustawia handler rodzica na SIGUSR1 (od P3).
   4. Tworzy procesy P1, P2, P3.
   5. Czeka na ich zakończenie (wait).
   6. Sprząta zasoby systemowe.
*/
int main(void) {
    /* Najpierw czyścimy zaszłości po poprzednich uruchomieniach */
    (void)unlink(FIFO_NAME);   /* FIFO */
    sem_unlink("/sem_2");
    sem_unlink("/sem_3");
    shm_unlink(SHM_NAME);

    /* ---- Kolejka "done" p3->p1 ---- */
    key_t key_p3_p1 = ftok(".", 'D');
    if (key_p3_p1 == -1) {
        die("ftok error (p3_p1)");
    }
    msgid_p3_p1 = msgget(key_p3_p1, 0666 | IPC_CREAT);
    if (msgid_p3_p1 == -1) {
        die("msgget p3->p1 error");
    }

    /* ---- 3 kolejki do sygnałów ---- */
    key_t k1 = ftok(".", 'A');
    key_t k2 = ftok(".", 'B');
    key_t k3 = ftok(".", 'C');
    if (k1 == -1 || k2 == -1 || k3 == -1) {
        die("ftok error (k1/k2/k3)");
    }
    msgid_p1 = msgget(k1, 0666 | IPC_CREAT);
    msgid_p2 = msgget(k2, 0666 | IPC_CREAT);
    msgid_p3 = msgget(k3, 0666 | IPC_CREAT);
    if (msgid_p1 < 0 || msgid_p2 < 0 || msgid_p3 < 0) {
        die("msgget (p1/p2/p3) error");
    }

    /* ---- Tworzymy semafory ---- */
    sem_2 = sem_open("/sem_2", O_CREAT | O_EXCL, 0666, 0);
    if (sem_2 == SEM_FAILED) {
        die("sem_open /sem_2 error");
    }
    sem_3 = sem_open("/sem_3", O_CREAT | O_EXCL, 0666, 0);
    if (sem_3 == SEM_FAILED) {
        die("sem_open /sem_3 error");
    }

    /* ---- Pamięć dzielona ---- */
    int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
    if (shm_fd == -1) {
        die("shm_open error");
    }
    if (ftruncate(shm_fd, ByteSize) == -1) {
        die("ftruncate error");
    }
    char *shared_memory = mmap(NULL, ByteSize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_memory == MAP_FAILED) {
        die("mmap error");
    }

    /* ---- Rodzic: ustawiamy handler SIGUSR1 (od P3) ---- */
    {
        struct sigaction sa;
        memset(&sa, 0, sizeof(sa));
        sa.sa_handler = parent_sigusr1_handler;
        sigaction(SIGUSR1, &sa, NULL);
    }

    /* ---- Ignorujemy inne sygnały w rodzicu (opcjonalnie) ---- */
    for (int i = 1; i < 32; i++) {
        if (i == SIGKILL || i == SIGSTOP || i == SIGUSR1)
            continue; /* nie da się przechwycić KILL/STOP, a SIGUSR1 używamy */
        signal(i, SIG_IGN);
    }

    /* ----------------- Tworzymy procesy potomne --------------- */
    pid1 = fork();
    if (pid1 == -1) {
        die("fork P1 error");
    }
    if (pid1 == 0) {
        P1();
    }

    pid2 = fork();
    if (pid2 == -1) {
        die("fork P2 error");
    }
    if (pid2 == 0) {
        P2(shared_memory);
    }

    pid3 = fork();
    if (pid3 == -1) {
        die("fork P3 error");
    }
    if (pid3 == 0) {
        P3(shared_memory);
    }

    /* ------------- Rodzic czeka na zakończenie dzieci ----------- */
    for (int i = 0; i < 3; i++) {
        int status = 0;
        pid_t w = wait(&status);
        if (w == -1) {
            perror("[Parent] wait error");
            continue;
        }
        printf("[Parent] Proces PID=%d zakończony, status=%d.\n", w, status);
    }

    /* -------------- Sprzątanie zasobów systemowych -------------- */
    /* semafory */
    sem_close(sem_2);
    sem_close(sem_3);
    sem_unlink("/sem_2");
    sem_unlink("/sem_3");

    /* pamięć dzielona */
    munmap(shared_memory, ByteSize);
    shm_unlink(SHM_NAME);

    /* kolejki */
    msgctl(msgid_p3_p1, IPC_RMID, NULL);
    msgctl(msgid_p1, IPC_RMID, NULL);
    msgctl(msgid_p2, IPC_RMID, NULL);
    msgctl(msgid_p3, IPC_RMID, NULL);

    /* FIFO */
    unlink(FIFO_NAME);

    printf("[Parent] Wszystkie procesy zakończone. Zasoby zwolnione.\n");
    return 0;
}
